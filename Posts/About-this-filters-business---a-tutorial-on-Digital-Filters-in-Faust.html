<!DOCTYPE html>
<html lang="en"><head><title>About this filters business - a tutorial on Digital Filters in Faust</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=IBM Plex Mono:wght@400;700&amp;family=IBM Plex Mono:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin="anonymous"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="og:site_name" content="Luca Spanedda"/><meta property="og:title" content="About this filters business - a tutorial on Digital Filters in Faust"/><meta property="og:type" content="website"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="About this filters business - a tutorial on Digital Filters in Faust"/><meta name="twitter:description" content="Preludes to Filter Syntax in Faust Constructing a delay line In FAUST the _ represent a signal input. A function with one input that goes directly to the output is written as follows: import(&quot;stdfaust.lib&quot;); // signal input - output //process = _; where process is the main function in Faust (the compiler’s output function)."/><meta property="og:description" content="Preludes to Filter Syntax in Faust Constructing a delay line In FAUST the _ represent a signal input. A function with one input that goes directly to the output is written as follows: import(&quot;stdfaust.lib&quot;); // signal input - output //process = _; where process is the main function in Faust (the compiler’s output function)."/><meta property="og:image:type" content="image/webp"/><meta property="og:image:alt" content="Preludes to Filter Syntax in Faust Constructing a delay line In FAUST the _ represent a signal input. A function with one input that goes directly to the output is written as follows: import(&quot;stdfaust.lib&quot;); // signal input - output //process = _; where process is the main function in Faust (the compiler’s output function)."/><meta property="og:image:width" content="1200"/><meta property="og:image:height" content="630"/><meta property="og:image:url" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta name="twitter:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="og:image" content="https://quartz.jzhao.xyz/static/og-image.png"/><meta property="twitter:domain" content="quartz.jzhao.xyz"/><meta property="og:url" content="https://quartz.jzhao.xyz/Posts/About-this-filters-business---a-tutorial-on-Digital-Filters-in-Faust"/><meta property="twitter:url" content="https://quartz.jzhao.xyz/Posts/About-this-filters-business---a-tutorial-on-Digital-Filters-in-Faust"/><link rel="icon" href="../static/icon.png"/><meta name="description" content="Preludes to Filter Syntax in Faust Constructing a delay line In FAUST the _ represent a signal input. A function with one input that goes directly to the output is written as follows: import(&quot;stdfaust.lib&quot;); // signal input - output //process = _; where process is the main function in Faust (the compiler’s output function)."/><meta name="generator" content="Quartz"/><link href="../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../static/contentIndex.json").then(data => data.json())</script></head><body data-slug="Posts/About-this-filters-business---a-tutorial-on-Digital-Filters-in-Faust"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h2 class="page-title"><a href="..">Luca Spanedda</a></h2><div class="spacer mobile-only"></div><div class="search"><button class="search-button" id="search-button"><p>Search</p><svg role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title>Search</title><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></button><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><div class="explorer"><button type="button" id="mobile-explorer" class="collapsed hide-until-loaded" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;Compositions&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Posts&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Studies&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Studies/PhD&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Studies/SMERM&quot;,&quot;collapsed&quot;:true}]" data-mobile="true" aria-controls="explorer-content" aria-expanded="false"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu"><line x1="4" x2="20" y1="12" y2="12"></line><line x1="4" x2="20" y1="6" y2="6"></line><line x1="4" x2="20" y1="18" y2="18"></line></svg></button><button type="button" id="desktop-explorer" class="title-button" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;Compositions&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Posts&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Studies&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Studies/PhD&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Studies/SMERM&quot;,&quot;collapsed&quot;:true}]" data-mobile="false" aria-controls="explorer-content" aria-expanded="true"><h2>Explorer</h2><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Compositions"><button class="folder-button"><span class="folder-title">Compositions</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Compositions"><li><a href="../Compositions/In-Finite" data-for="Compositions/In-Finite">In-Finite</a></li><li><a href="../Compositions/RITI---Room-Is-The-Instrument" data-for="Compositions/RITI---Room-Is-The-Instrument">RITI - Room Is The Instrument</a></li><li><a href="../Compositions/Waste-Kompost-Radio" data-for="Compositions/Waste-Kompost-Radio">Waste Kompost Radio</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Posts"><button class="folder-button"><span class="folder-title">Posts</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Posts"><li><a href="../Posts/About-this-filters-business---a-tutorial-on-Digital-Filters-in-Faust" data-for="Posts/About-this-filters-business---a-tutorial-on-Digital-Filters-in-Faust">About this filters business - a tutorial on Digital Filters in Faust</a></li><li><a href="../Posts/Digital-Reverberation---a-tutorial-in-Faust" data-for="Posts/Digital-Reverberation---a-tutorial-in-Faust">Digital Reverberation - a tutorial in Faust</a></li><li><a href="../Posts/Exploring-Pseudo-Random-and-Stochastic-Signals-in-Digital-Sound-Synthesis" data-for="Posts/Exploring-Pseudo-Random-and-Stochastic-Signals-in-Digital-Sound-Synthesis">Exploring Pseudo-Random and Stochastic Signals in Digital Sound Synthesis</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Studies"><button class="folder-button"><span class="folder-title">Studies</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Studies"><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Studies/PhD"><button class="folder-button"><span class="folder-title">PhD</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Studies/PhD"><li><a href="../Studies/PhD/PhD" data-for="Studies/PhD/PhD">PhD</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Studies/SMERM"><button class="folder-button"><span class="folder-title">SMERM</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Studies/SMERM"><li><a href="../Studies/SMERM/SMERM" data-for="Studies/SMERM/SMERM">SMERM</a></li></ul></div></li></ul></div></li><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li><li><a href="../Biography" data-for="Biography">Biography</a></li><li><a href="../Blog" data-for="Blog">Blog</a></li><li><a href="../Contact" data-for="Contact">Contact</a></li><li><a href="../CV" data-for="CV">CV</a></li><li><a href="../Links" data-for="Links">Links</a></li></ul></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../Posts/">Posts</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>About this filters business - a tutorial on Digital Filters in Faust</a></div></nav><h1 class="article-title">About this filters business - a tutorial on Digital Filters in Faust</h1><p show-comma="true" class="content-meta"><time datetime="2025-03-04T09:36:25.321Z">Mar 04, 2025</time><span>18 min read</span></p></div></div><article class="popover-hint"><h2 id="preludes-to-filter-syntax-in-faust">Preludes to Filter Syntax in Faust<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#preludes-to-filter-syntax-in-faust" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="constructing-a-delay-line">Constructing a delay line<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#constructing-a-delay-line" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>In FAUST the <code>_</code> represent a signal input.
A function with one input that goes directly to the output is written as follows:</p>
<pre><code>import(&quot;stdfaust.lib&quot;);

// signal input - output
//process = _;
</code></pre>
<p>where <code>process</code> is the <em><strong>main</strong></em> function in Faust (the compiler’s output function).
And <code>import(&quot;stdfaust.lib&quot;);</code> is the function for import the Standard Faust Libraries.</p>
<p>Faust provides us with three different syntaxes to express a delay line:</p>
<ul>
<li><code>'</code> - is used to express a one sample delay. Time expressions can be chained, so the output signal of this program</li>
</ul>
<pre><code>// signal in delay (' = mem), (mem = Z^(-1)) 
 //process = _''; 
</code></pre>
<p>will produce a delayed signal of two samples.</p>
<ul>
<li><code>mem</code> - indicates a 1 sample delay. You can use the “mem” successively add delay samples, so the output signal of this program</li>
</ul>
<pre><code>// signal in delay (' = mem), (mem = Z^(-1)) 
//process = _ : mem : mem : _; 
</code></pre>
<p>will produce a delayed signal of two samples.
<strong>These last two programs produce the same result.</strong></p>
<p><code>@</code> - indicates a number of variable delay samples, so for example a signal with 192000 samples of delay is written like:</p>
<pre><code> // signal in delay (@192000 = 192000 samples of delay) 
 //process = _ @ 192000; 
</code></pre>
<hr/>
<h3 id="dirac-impulse">Dirac impulse<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#dirac-impulse" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Now, another element that we can introduce through the filter syntax is the Dirac impulse, which represents our minimum DSP unit, namely the single sample
by putting a number 1 and subtracting the same value from it
but doing it at a delayed sample.</p>
<p>Example:</p>
<pre><code>// Dirac Impulse with delay lines - Impulse at Compile Time  
 dirac0 = 1 - 1';  
 //process = dirac0; 
</code></pre>
<p>or something like that using functional syntax:</p>
<pre><code>// Dirac Impulse with delay lines - Impulse at Compile Time  
 dirac1(x) = x - x';  
 //process = dirac1(1); 
</code></pre>
<hr/>
<h3 id="methods-for-implementing-recursive-circuits-in-the-faust-language">Methods for Implementing Recursive Circuits in the Faust Language<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#methods-for-implementing-recursive-circuits-in-the-faust-language" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Now we will illustrate three main methods for Implementing Recursive Circuits in FAUST Language:</p>
<ul>
<li>Writing the code line with internal recursion:
in this way <em>tilde</em> <code>~</code> operator sends the signal
output to itself, to the first available input
creating a feedback circuit.</li>
</ul>
<p>One way to force the operator to point to a certain point
in the code, is to put parentheses <code>()</code>, in this way <code>~</code>
will point to the input before the parenthesis.
In this program, the input is summed with itself delayed by one sample and multiplied by 0.5:</p>
<pre><code>// dirac in feedback in sin 
//process = (1 - 1') * 1000 : (_ + _) ~ _ * (0.9999) : sin;
</code></pre>
<ul>
<li>Using the with construction <code>with{};</code>:
It can be used to create a local enviroment.
You can define a function in which are passed
the various arguments of the function that control
the parameters of the code,
and say that that function is equal to
exit from the with, with <code>~ _</code>.
You can find an exhaustive explanation of <a href="https://faustdoc.grame.fr/manual/syntax/index.html#with-expression" class="external">with construction here<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></li>
</ul>
<p>Example:</p>
<pre><code> // with environment example (dirac in feedback in sin) 
 //where out ~ _ returns to itself. 
 function_with(input1, input2) = out ~ _ : sin 
     	with{   
      		section1 = (1 - 1') * input1; 
      		section2(argument1) = (argument1 * input2) + section1; 
      		out = section2; 
      	}; 
 //process = function_with(1000, 0.9999); 
</code></pre>
<p>Moreover, with in Faust allows declaring variables
that are not pointed to from outside the code but only
from the belonging function; in this case</p>
<p><strong>the function to which with belongs is “function_with”.</strong></p>
<ul>
<li>
<p>A third method is to use the letrec environment.
with this method we can write a signal
recursively, similar to how
recurrence equations are written.</p>
<pre><code>// letrec function  
 function_letrec = sin(y) 
 // letrec definition  
 	letrec {  
  		'y = dirac * damp + amp * y;  
  	}  
  	// inside the letrec function  
     with {  
         dirac = (1 - 1'); 
         damp = 1000; 
         amp = 0.9999; 
     };  
//process = function_letrec &lt;: si.bus(2);
</code></pre>
</li>
</ul>
<hr/>
<p>Concluding this chapter on filter syntax in FAUST, we need to introduce a fundamental concept
that will help us gain a more comprehensive understanding of digital filters:
the relationship between milliseconds and samples <span>→</span> sampling frequency.</p>
<h2 id="milliseconds---samples-and-the-importance-of-the-sampling-frequency">Milliseconds - Samples and the importance of the sampling frequency<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#milliseconds---samples-and-the-importance-of-the-sampling-frequency" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>Digital filters differ from analog filters for one particular reason: the Analog-to-Digital (AD)
conversion system involves discretizing a continuous physical phenomenon into a sampled numerical one.
Understanding the relationship between time and samples helps us in reasoning and practical
applications of digital filters. These filters indeed entail spectral changes
(when observed in the frequency domain) and involve temporal integration
changes (when observed in the time domain).
This brief preamble will be explained further in the chapter on the bilinear transform.
For now, let’s focus on small examples of converting between milliseconds and samples.</p>
<h3 id="conversion-from-milliseconds-to-samples">Conversion from Milliseconds to Samples<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#conversion-from-milliseconds-to-samples" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>This program takes input time expressed in milliseconds
and returns the value in samples.</p>
<pre><code>// milliseconds to samples conversion 
milliseconds = 10; 
msec2samps(msec) = msec * (ma.SR/1000); 
//process = msec2samps(milliseconds);
</code></pre>
<p>Through <code>ma.SR</code>, we use the current sampling frequency of
the machine we are using.
For example, if we have a sampling frequency
of <strong>96000</strong> samples per second,
it means that 1000ms (1 second) is represented
by <strong>96000 parts</strong>, and therefore <strong>a single unit
of time</strong> like 1ms <strong>corresponds</strong> digitally to <strong>96 samples</strong>.
For this reason, we divide the sampling frequency
by 1000ms, resulting in a total number of samples
that corresponds to 1ms in the digital world at
a certain sampling frequency.
And then we multiply the result of this operation
by the total number of milliseconds we want to obtain as
a representation in samples.
If we multiply by 100 we will have
<strong>9600 samples every 100ms</strong> at a sampling frequency
of 96000 samples per second.</p>
<h3 id="conversion-from-samples-to-milliseconds">Conversion from Samples to Milliseconds<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#conversion-from-samples-to-milliseconds" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Function for Conversion from Samples to Milliseconds:
we input a total number of samples,
of which we need to know the overall duration
in milliseconds based on our sampling frequency.</p>
<p>We know that a sampling frequency
corresponds to a set of values that express
together the duration of 1 second (1000 ms).</p>
<p>It means, for example,
that at a sampling frequency of 48,000
samples per second,
1000 milliseconds are represented by 48,000 parts.
So if we divide our 1000ms. /
into the 48,000 parts which are the samples of our system,
we would get the duration in milliseconds of a single sample
at that sampling frequency,
in this case therefore:
1000 / 48,000 = 0.02ms.
And so the duration in milliseconds of a single sample at 48,000
samples per second, is 0.02 milliseconds.
If we multiply the obtained number *
a total number of samples, we will get the time in milliseconds
of those samples for that sampling frequency used.</p>
<p>Obviously, as can be deduced from the considerations,
as the sampling frequency increases,
the temporal duration of a single sample decreases,
and thus a greater definition.</p>
<h2 id="phase-alignment-of-feedback">Phase Alignment of Feedback<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#phase-alignment-of-feedback" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<p>We need to spend a few words about the implementation of a delay line in feedback in the digital world.
In the following program, we have a Dirac impulse that is summed by itselfs delayed by 2 samples.</p>
<pre><code>// dirac delayed 
//process = (_ + (1 - 1')) ~ _ @2; 
</code></pre>
<p>We expect these values to appear in the first 10 samples:</p>

















































<div class="table-container"><table><thead><tr><th>nth sample</th><th>value</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr><tr><td>2</td><td>1</td></tr><tr><td>3</td><td>0</td></tr><tr><td>4</td><td>1</td></tr><tr><td>5</td><td>0</td></tr><tr><td>6</td><td>1</td></tr><tr><td>7</td><td>0</td></tr><tr><td>8</td><td>1</td></tr><tr><td>9</td><td>0</td></tr></tbody></table></div>
<p>However, the results of the data plot are as follows:</p>

















































<div class="table-container"><table><thead><tr><th>nth sample</th><th>value</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>0</td></tr><tr><td>2</td><td>0</td></tr><tr><td>3</td><td>1</td></tr><tr><td>4</td><td>0</td></tr><tr><td>5</td><td>0</td></tr><tr><td>6</td><td>1</td></tr><tr><td>7</td><td>0</td></tr><tr><td>8</td><td>0</td></tr><tr><td>9</td><td>1</td></tr></tbody></table></div>
<p>There’s something wrong. With each feedback cycle, it’s being delayed by one extra sample!
That’s because in the digital domain, the feedback of a
delay line, when applied, costs by default one sample delay.
‘<em>Feedback = 1 Sample</em>’</p>
<p>So one must consider that the number of delay samples equals the number of samples minus 1:</p>
<pre><code>// dirac delayed + phase alignment 
delSampsDirac0 = 2; 
//process = (_ + (1 - 1')) ~ _@(delSampsDirac0 - 1);
</code></pre>
<p>In some application scenarios later on, we’ll need a one-sample delay even at the input signal.
In this case, simply concatenating a delay line in series will suffice.</p>
<pre><code>// dirac delayed + phase alignment (final) 
delSampsDirac1 = 2; 
//process = (_ + (1 - 1')) ~ _@(delSampsDirac1 - 1) : mem;
</code></pre>
<hr/>
<h2 id="digital-filters">Digital Filters<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#digital-filters" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h2>
<h3 id="onezero-filter-1st-order-fir">ONEZERO FILTER (1st Order FIR)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#onezero-filter-1st-order-fir" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>_</code> represents the input signal, (<code>_</code> denotes the signal)
it is then split into two parallel paths <code>&lt;:</code>
one delayed by one sample <code>_'</code> (<code>'</code> denotes one sample delay)
and one without delay, <code>_</code> (<code>,</code> denotes transition to the second path)
they are then summed into a single signal <code>:> _ ;</code>
the delayed signal has a feedforward amplitude control <code>* feedforward</code>
there is a general amplitude control <code>* outgain</code>
on the output function onezeroout</p>
<pre><code>// onezero, g = give amplitude 0 to +/- 1 (open - close) to the delayed signal  
oz(b1) = _ &lt;: (_ : mem * b1), _ :> +;  
//process = oz; 
</code></pre>
<h3 id="onepole-filter-1st-order-iir">ONEPOLE FILTER (1st Order IIR)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#onepole-filter-1st-order-iir" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>+ ~</code> is the summation, and the feedback of the arguments inside parentheses <code>()_</code> represents the input signal, (<code>_</code> denotes the signal) delayed by one sample <code>_</code> (automatically in the feedback) which enters : into the gain control of the <code>feedback * 1-feedback</code> the same feedback controls the input amplification of the signal not injected into the feedback there is a general amplitude control <code>* outgain</code> on the output function onezeroout</p>
<pre><code>// onepole, g = give amplitude 0 to +/- 1 (open - close) to the delayed signal  
op(b1) = _ * (1 - abs(b1)) : + ~ * (b1); 
//process = op; 
</code></pre>
<p>and OPF with Frequency Cut transfer functions:</p>
<ul>
<li>(1)</li>
</ul>
<pre><code>// onepole with frequency cut formula (chamberlin), fc = Hz 
lp1p(fc) = _ * g : + ~ * (1 - g) 
    with{ 
        k(x) = x / (1.0 + x); 
        g = tan(fc * ma.PI / SR) : k; 
    }; 
//process = lp1p; 
</code></pre>
<ul>
<li>(2)</li>
</ul>
<pre><code>lp1p2(fc) = _ * (1 - b1) : + ~ * (b1) 
      with { 
           b1 = exp((fc * ma.PI / ma.SR) * -1); 
      }; 
//process = lp1p2; 
</code></pre>
<p>same OPF with Formulae expressed in Seconds (1 / FC)</p>
<ul>
<li>(3)</li>
</ul>
<pre><code>// onepole in seconds or smooth function 
opsec(sec) = _ * g : + ~ * (1 - g) 
    with{ 
        k(x) = x / (1.0 + x); 
        g = tan((1 / sec) * ma.PI / ma.SR) : k; 
    }; 
//process = opsec; 
</code></pre>
<hr/>
<h3 id="feedforward-comb-filter-nth-order-fir">FEEDFORWARD COMB FILTER (Nth Order FIR)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#feedforward-comb-filter-nth-order-fir" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>_</code> represents the input signal, (<code>_</code> denotes the signal) it is then split into two parallel paths <code>&lt;:</code> one delayed by <code>@(delaysamples)</code> samples (thus value to be passed externally) and one without delay, <code>_</code> (<code>,</code> denotes transition to the second path) they are then summed into a single signal <code>:> _ ;</code></p>
<p>the delayed signal has a feedforward amplitude control <code>* feedforward</code></p>
<p>there is a general amplitude control <code>* outgain</code> on the output function onezeroout</p>
<pre><code>// feedforward comb filter, (t, g) = delay time in samples, filter gain 0-1  
ffcf(t, g) = _ &lt;: ((_ @ (t)) * g), _ :> +;  
//process = (1000, 0.9, _) : ffcf; 
</code></pre>
<h3 id="feedback-comb-filter-nth-order-iir">FEEDBACK COMB FILTER (Nth Order IIR)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#feedback-comb-filter-nth-order-iir" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p><code>+ ~</code> is the summation, and the feedback of the arguments inside parentheses <code>() _</code> represents the input signal, (<code>_</code> denotes the signal) delayed by <code>@(delaysamples)</code> samples (thus value to be passed externally) which enters : into the gain control of the feedback, <code>* feedback</code></p>
<p>In the feedback, one sample of delay is already present by default, hence <code>delaysamples-1</code>.</p>
<p>there is a general amplitude control <code>* outgain</code> on the output function combfeedbout</p>
<pre><code>// feedback comb filter, (t, g) = give: delay time in samples, feedback gain 0-1 
fbcf(t, g) = _ : (+  @(t - 1) ~ *(g)) : mem; 
//process = (1000, 0.9, _) : fbcf; 
</code></pre>
<h3 id="lowpass-feedback-comb-filter-nth-order-iir">Lowpass FEEDBACK COMB FILTER (Nth Order IIR)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#lowpass-feedback-comb-filter-nth-order-iir" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>similar to the comb filter, but within the feedback, following the feedback enters the signal : into the onepole. The onepole is a lowpass where the cutoff frequency can be controlled between 0. and 1. In the feedback, one sample of delay is already present by default, hence <code>delaysamples-1</code>.</p>
<pre><code>// lowpass feedback comb filter, (t, g) = give: delay time in samples, g gain 0-1, Freq cut (HZ) 
lbcf(t, g, fc) = _ : (+  @(t - 1) ~ (lp1p(fc) * (g))) : mem; 
//process = (1000, 0.9, 10000, _) : lbcf; 
</code></pre>
<hr/>
<h3 id="allpass-filter">ALLPASS FILTER<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#allpass-filter" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>from the sum of a comb IIR and a comb FIR in opposition of phase, emerge a recursive delay unit that preserve the phase of the input signal. (<code>+</code> transitions : to a cable <code>_</code> and a split <code>&lt;:</code> then <code>@delay</code> and gain, in <code>feedback ~</code> to the initial sum. filtergain controls the amplitude of the two gain states, which in the filter are the same value but positive and negative, one side <code>* -filtergain</code> and one side <code>* +filtergain</code>. In the feedback, one sample of delay is already present by default, hence <code>delaysamples-1</code>. To maintain the delay threshold of the value delaysamples, a mem delay (of the subtracted sample) is added at the end.</p>
<pre><code>// allpass filter, (t, g) = give: delay in samples, feedback gain 0-1 
apf(t, g) = _ : (+ : _ &lt;: @(t  - 1), *(g))~ *(-g) : mem, _ : + : _; 
//process = (1000, 0.9, _) : apf; 
</code></pre>
<h3 id="modulated-allpass-filter">MODULATED ALLPASS FILTER<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#modulated-allpass-filter" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Allpass Filter with Time-Variant delay</p>
<pre><code>// Modulated Allpass filter 
modapf(delsamples, samplesmod, freqmod, apcoeff) = ( + : _ &lt;:  
    delayMod(delsamples, samplesmod, freqmod), 
    * (apcoeff))~ * (-apcoeff) : mem, _ : + : _ 
    with{ 
        delayMod(samples, samplesMod, freqMod, x) = delay 
        with{ 
            unipolarMod(f, samples) = ((os.osc(f) + 1) / 2) * samples; 
            delay = x : de.fdelay(samples, samples - unipolarMod(freqMod, samplesMod)); 
        }; 
    }; 
//process = _ &lt;: modapf(1100, 800, .12, .99), modapf(1000, 900, .12, .99); 
</code></pre>
<hr/>
<h3 id="state-variable-filter-svf">STATE VARIABLE FILTER (SVF)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#state-variable-filter-svf" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>State variable filters are second-order RC active filters consisting of two identical op-amp
integrators with each one acting as a first-order, single-pole low pass filter,
a summing amplifier around which we can set the filters gain and its damping feedback network.
The output signals from all three op-amp stages are fed back to the input
allowing us to define the state of the circuit.
The state variable filter is a type of multiple-feedback filter circuit
that can produce all three filter responses, Low Pass, High Pass and Band Pass
simultaneously from the same single active filter design, and derivation
like Notch, Peak, Allpass…</p>
<h3 id="robert-bristow-johnsons-svf-biquad">Robert Bristow Johnson’s SVF Biquad<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#robert-bristow-johnsons-svf-biquad" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>This filter transfer functions were derived from analog prototypes (that
are shown below for each EQ filter type) and had been digitized using the
Bilinear Transform by Robert Bristow-Johnson: <a href="https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html" class="external">https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a></p>
<pre><code>// Robert Bristow-Johnson's Biquad Filter - Direct Form 1 
// https://webaudio.github.io/Audio-EQ-Cookbook/audio-eq-cookbook.html 
biquad(i, cf, q) = _ : coefficients(i) : biquadFilter 
     with{ 
         biquadFilter(a0, a1, a2, b1, b2) = biquadFilter 
             with{ 
                 biquadFilter =  _ &lt;: _, (mem  &lt;: (_, mem)) : (_ * a0, _ * a1, _ * a2) :> _ :  
                                 ((_, _) :> _) ~ (_ &lt;: (_, mem) : (_ * -b1, _ * -b2) :> _); 
             }; 
  
         // Angular Frequency formula 
         omega(x) = (2 * ma.PI * x) / ma.SR; 
         // Angular Frequency in the sine domain 
         sn(x) = sin(omega(x)); 
         // Angular Frequency in the cosine domain 
         cs(x) = cos(omega(x));  
         // Alpha 
         alpha(cf0, q0) = sin(omega(cf0)) / (2 * q0); 
  
         // Robert Bristow-Johnson's Biquad Filter - Coefficents 
         // Lowpass Filter 
         coefficients(0) = a0, a1, a2, b1, b2, _ 
         with{ 
             b0 = (1 + alpha(cf, q)); 
             a0 = ((1 - cs(cf)) / 2) / b0; 
             a1 = (1 - cs(cf)) / b0; 
             a2 = ((1 - cs(cf)) / 2) / b0; 
             b1 = (-2 * cs(cf)) / b0; 
             b2 = (1 - alpha(cf, q)) / b0; 
         }; 
         // Highpass filter 
         coefficients(1) = a0, a1, a2, b1, b2, _ 
         with{ 
             b0 = (1 + alpha(cf, q)); 
             a0 = ((1 + cs(cf)) / 2) / b0; 
             a1 = (-1 * (1 + cs(cf))) / b0; 
             a2 = ((1 + cs(cf)) / 2) / b0; 
             b1 = (-2 * cs(cf)) / b0; 
             b2 = (1 - alpha(cf, q)) / b0; 
         }; 
         // Bandpass Filter 
         coefficients(2) = a0, a1, a2, b1, b2, _ 
         with{ 
             b0 = 1 + alpha(cf, q); 
             a0 = alpha(cf, q) / b0; 
             a1 = 0; 
             a2 = - alpha(cf, q) / b0; 
             b1 = (-2 * cs(cf)) / b0; 
             b2 = (1 - alpha(cf, q)) / b0; 
         }; 
         // Notch filter 
         coefficients(3) = a0, a1, a2, b1, b2, _ 
         with{ 
             b0 = 1 + alpha(cf, q); 
             a0 = 1 / b0; 
             a1 = (-2 * cs(cf)) / b0; 
             a2 = 1 / b0; 
             b1 = (-2 * cs(cf)) / b0; 
             b2 = (1 - alpha(cf, q)) / b0; 
         }; 
         // Peaking EQ filter 
         coefficients(4) = a0, a1, a2, b1, b2, _ 
         with{ 
             A = 10; 
             b0 = 1 + (alpha(cf, q) / A); 
             a0 = (1 + (alpha(cf, q) * A)) / b0; 
             a1 = (-2 * cs(cf)) / b0; 
             a2 = (1 - (alpha(cf, q) * A)) / b0; 
             b1 = (-2 * cs(cf)) / b0; 
             b2 = (1 - (alpha(cf, q) / A)) / b0; 
         }; 
         // Low Shelf Filter 
         coefficients(5) = a0, a1, a2, b1, b2, _ 
         with{ 
             //dbGain 20; 
             A  = pow(10, -20 /40); 
             beta = sqrt(A + A); 
             b0 = (A + 1) + (A - 1) * cs(cf) + beta * alpha(cf, q); 
             a0 = (A * ((A + 1) - (A - 1) * cs(cf) + beta * alpha(cf, q))) /b0; 
             a1 = (2 * A * ((A - 1) - (A + 1) * cs(cf))) / b0; 
             a2 = (A * ((A + 1) - (A - 1) * cs(cf) - beta * alpha(cf, q))) /b0; 
             b1 = (-2 * ((A - 1) + (A + 1) * cs(cf))) / b0; 
             b2 = ((A + 1) + (A - 1) * cs(cf) - beta * alpha(cf, q)) / b0; 
         }; 
         // High Shelf Filter 
         coefficients(6) = a0, a1, a2, b1, b2, _ 
         with{ 
             //dbGain 20; 
             A  = pow(10, -20 /40); 
             beta = sqrt(A + A); 
             b0 = (A + 1) - (A - 1) * cs(cf) + beta * alpha(cf, q); 
             a0 = (A * ((A + 1) + (A - 1) * cs(cf) + beta * alpha(cf, q))) /b0; 
             a1 = (2 * A * ((A - 1) + (A + 1) * cs(cf))) / b0; 
             a2 = (A * ((A + 1) + (A - 1) * cs(cf) - beta * alpha(cf, q))) /b0; 
             b1 = (2 * ((A - 1) - (A + 1) * cs(cf))) / b0; 
             b2 = ((A + 1) - (A - 1) * cs(cf) - beta * alpha(cf, q)) / b0; 
         }; 
}; 
//process = (1000, 1, _) : biquad(0); 
</code></pre>
<hr/>
<h3 id="onepole-topology-preserving-transforms-tpt">ONEPOLE Topology Preserving Transforms (TPT)<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#onepole-topology-preserving-transforms-tpt" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>TPT version of the One-Pole Filter by Vadim Zavalishin
reference: <a href="https://www.native-instruments.de/fileadmin/redaktion_upload/pdf/KeepTopology.pdf" class="external">https://www.native-instruments.de/fileadmin/redaktion_upload/pdf/KeepTopology.pdf<svg aria-hidden="true" class="external-icon" style="max-width:0.8em;max-height:0.8em;" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>
the topology-preserving transform approach, can be considered as
a generalization of bilinear transform, zero-delay feedback and trapezoidal integration methods. This results in digital filters having nice amplitude and phase
responses, nice time-varying behavior and plenty of options for nonlinearities</p>
<pre><code>// Vadim Zavalishin's Onepole TPT Filter (Topology Preserving Transform)  
onePoleTPT(cf, x) = loop ~ _ : ! , si.bus(3) 
     with { 
         g = tan(cf * PI * ma.T); 
         G = g / (1.0 + g); 
         loop(s) = u , lp , hp , ap 
             with { 
             v = (x - s) * G; u = v + lp; lp = v + s; hp = x - lp; ap = lp - hp; 
             }; 
     }; 
//process = onePoleTPT; 
  
// Lowpass and Highpass TPT 
LPTPT(cf, x) = onePoleTPT(cf, x) : (_ , ! , !); 
HPTPT(cf, x) = onePoleTPT(cf, x) : (! , _ , !); 
  
// Allpass TPT 
APTPT(cf, x) = onePoleTPT(cf, x) : (!, !, _); 
</code></pre>
<h3 id="vadim-zavalishins-svf-topology-preserving-transform">Vadim Zavalishin’s SVF Topology Preserving Transform<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#vadim-zavalishins-svf-topology-preserving-transform" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<pre><code>// Vadim Zavalishin's SVF TPT filter (Topology Preserving Transform) 
SVFTPT(Q, cf, x) = loop ~ si.bus(2) : (! , ! , _ , _ , _ , _ , _) 
     with { 
         g = tan(cf * ma.PI * ma.T); 
         R = 1.0 / (2.0 * Q); 
         G1 = 1.0 / (1.0 + 2.0 * R * g + g * g); 
         G2 = 2.0 * R + g; 
         loop(s1, s2) = u1 , u2 , lp , hp , bp * 2.0 * R , x - bp * 4.0 * R , bp 
             with { 
                 hp = (x - s1 * G2 - s2) * G1; 
                 v1 = hp * g; 
                 bp = s1 + v1; 
                 v2 = bp * g; 
                 lp = s2 + v2; 
                 u1 = v1 + bp; 
                 u2 = v2 + lp; 
             }; 
     }; 
  
// HP - LP SVF  
LPSVFTPT(Q, cf, x) = SVFTPT(Q, cf, x) : (_ , ! , ! , ! , !); 
HPSVFTPT(Q, cf, x) = SVFTPT(Q, cf, x) : (! , _ , ! , ! , !); 
  
// Normalized Bandpass SVF  
BPSVFTPT(Q, cf, x) = SVFTPT(Q, cf, x) : (! , ! , _ , ! , !); 
  
NotchSVFTPT(Q, cf, x) = x - BPSVF(Q, cf, x); 
APSVFTPT(Q, cf, x) = SVFTPT(Q, cf, x) : (! , ! , ! , _ , !); 
PeakingSVFTPT(Q, cf, x) = LPSVF(Q, cf, x) - HPSVF(Q, cf, x); 
BP2SVFTPT(Q, cf, x) = SVFTPT(Q, cf, x) : (! , ! , ! , ! , _); 
  
// Bandpass Bandwidth SVF 
BPBWSVFTPT(BW, CF, x) = BPSVF(clip(20000, EPS, (CF / BW)), CF, x); 
</code></pre></article><hr/><div class="page-footer"></div></div><div class="right sidebar"><button class="darkmode" id="darkmode"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve" aria-label="Dark mode"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve" aria-label="Light mode"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></button><div class="graph"><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:false,&quot;enableRadial&quot;:false}"></div><button id="global-graph-icon" aria-label="Global Graph"><svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xml:space="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
                s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
                c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
                C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
                c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
                v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
                s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
                C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
                S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
                s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
                s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></button></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[],&quot;focusOnHover&quot;:true,&quot;enableRadial&quot;:true}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc" class aria-controls="toc-content" aria-expanded="true"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content" class><ul class="overflow"><li class="depth-0"><a href="#preludes-to-filter-syntax-in-faust" data-for="preludes-to-filter-syntax-in-faust">Preludes to Filter Syntax in Faust</a></li><li class="depth-1"><a href="#constructing-a-delay-line" data-for="constructing-a-delay-line">Constructing a delay line</a></li><li class="depth-1"><a href="#dirac-impulse" data-for="dirac-impulse">Dirac impulse</a></li><li class="depth-1"><a href="#methods-for-implementing-recursive-circuits-in-the-faust-language" data-for="methods-for-implementing-recursive-circuits-in-the-faust-language">Methods for Implementing Recursive Circuits in the Faust Language</a></li><li class="depth-0"><a href="#milliseconds---samples-and-the-importance-of-the-sampling-frequency" data-for="milliseconds---samples-and-the-importance-of-the-sampling-frequency">Milliseconds - Samples and the importance of the sampling frequency</a></li><li class="depth-1"><a href="#conversion-from-milliseconds-to-samples" data-for="conversion-from-milliseconds-to-samples">Conversion from Milliseconds to Samples</a></li><li class="depth-1"><a href="#conversion-from-samples-to-milliseconds" data-for="conversion-from-samples-to-milliseconds">Conversion from Samples to Milliseconds</a></li><li class="depth-0"><a href="#phase-alignment-of-feedback" data-for="phase-alignment-of-feedback">Phase Alignment of Feedback</a></li><li class="depth-0"><a href="#digital-filters" data-for="digital-filters">Digital Filters</a></li><li class="depth-1"><a href="#onezero-filter-1st-order-fir" data-for="onezero-filter-1st-order-fir">ONEZERO FILTER (1st Order FIR)</a></li><li class="depth-1"><a href="#onepole-filter-1st-order-iir" data-for="onepole-filter-1st-order-iir">ONEPOLE FILTER (1st Order IIR)</a></li><li class="depth-1"><a href="#feedforward-comb-filter-nth-order-fir" data-for="feedforward-comb-filter-nth-order-fir">FEEDFORWARD COMB FILTER (Nth Order FIR)</a></li><li class="depth-1"><a href="#feedback-comb-filter-nth-order-iir" data-for="feedback-comb-filter-nth-order-iir">FEEDBACK COMB FILTER (Nth Order IIR)</a></li><li class="depth-1"><a href="#lowpass-feedback-comb-filter-nth-order-iir" data-for="lowpass-feedback-comb-filter-nth-order-iir">Lowpass FEEDBACK COMB FILTER (Nth Order IIR)</a></li><li class="depth-1"><a href="#allpass-filter" data-for="allpass-filter">ALLPASS FILTER</a></li><li class="depth-1"><a href="#modulated-allpass-filter" data-for="modulated-allpass-filter">MODULATED ALLPASS FILTER</a></li><li class="depth-1"><a href="#state-variable-filter-svf" data-for="state-variable-filter-svf">STATE VARIABLE FILTER (SVF)</a></li><li class="depth-1"><a href="#robert-bristow-johnsons-svf-biquad" data-for="robert-bristow-johnsons-svf-biquad">Robert Bristow Johnson’s SVF Biquad</a></li><li class="depth-1"><a href="#onepole-topology-preserving-transforms-tpt" data-for="onepole-topology-preserving-transforms-tpt">ONEPOLE Topology Preserving Transforms (TPT)</a></li><li class="depth-1"><a href="#vadim-zavalishins-svf-topology-preserving-transform" data-for="vadim-zavalishins-svf-topology-preserving-transform">Vadim Zavalishin’s SVF Topology Preserving Transform</a></li></ul></div></div><div class="backlinks"><h3>Backlinks</h3><ul class="overflow"><li><a href="../Blog" class="internal">Blog</a></li></ul></div></div><footer class><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.4.0</a> © 2025</p><ul><li><a href="https://github.com/jackyzha0/quartz">GitHub</a></li><li><a href="https://discord.gg/cRFFHYye7t">Discord Community</a></li></ul></footer></div></div></body><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">
        const socket = new WebSocket('ws://localhost:3001')
        // reload(true) ensures resources like images and scripts are fetched again in firefox
        socket.addEventListener('message', () => document.location.reload(true))
      </script><script src="../postscript.js" type="module"></script></html>